# Шедеврогайд по авх
> Если есть возражения или предложения по этому гайду, то мяукните мне в тг: @o2kar1n, или Егору @m256i

> Респект мистеру Егору за помощь в создании

### Оглавление
* [Так называемое введение](#так-называемое-введение)
* [Первая задача](#сравнение-2-строк)
    * [Заключение](#так-называемое-заключение)
* [Ближе к делу](#ближе-к-делу)
    * [Так называемая идейность](#так-называемая-идейность)
* [Базовый минимум функций](#базовый-минимум-функций)
* [Оценка скорости](#оценка-скорости)
* [Ускорение lddqu/loadu и storeu](#ускорение-lddquloadu-и-storeu)
* [Лонги?](#лонги)
* [Советы](#подпивасные-советы)
* [Пример с числовыми массивами](#пример-с-числовыми-массивами)
* [Еще один пример](#примеры-на-серьезной-задаче)
* [Итоги](#подведем-итоги)

### Так называемое введение
Хотели бы вы запихать $10 ^ {10}$ в секунду? Авх вам поможет!!!

>Миниприкол: совсем простые вещи современный компиль может сам соптимайзить, поэтому моментами можно будет не писать все ручками.

### Сравнение 2 строк

напишем функцию для сравнения 2 строк одиннаковой длины:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```

Тут видно, что он работает за n

попробуем это ускорить, а именно будем вместо чаров фигачить лонги, ведь как мы знаем в 1 лонг лонг можно запихать 8 чаров

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    for (; i + 8 <= n; i += 8) {
        long long x = *(long long*)&s[i];
        long long y = *(long long*)&t[i];
        if (x != y)
            return false;
    }

    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```
> Не стоит забывать что длина может не быть кратной 8, поэтому надо еще проверить остаток.

Что тут произошло:  
Мы взяли и перекастовали 8 чаров в 1 лонг лонг. И работали сразу с 8 элементами.

Вот щас вы подумаете, что это будет работать в 8 раз быстрее, но увы реальность полна разочарований. Давайте глянем на тесты:

> Время измерялось таким образом:
> ```
> auto start = clock();
> cout << is_eq(s, t, N) << '\n';
> auto end = clock();
> double time = (double)(end - start) / CLOCKS_PER_SEC;
> cout << time;
> ```

сравним 2 одиннаковые строки при $N =  10 ^ 9 $:

| первый вариант | второй вариант |
|----------------|----------------|
|1.22s            |0.4s            |


Но буст всеравно хороший. Поэтому такие смешные штуки делать можно.

Еще из смешного можно разворачивать циклы.

> Если вы не знали, то существует прагма которая разворачивает циклы: `#pragma GCC optimize("unroll-loops")`, но ручками может быть быстрее

Давайте попробуем это сделать:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    for (; i + 16 <= n; i += 16) {
        long long x = *(long long*)&s[i];
        long long y = *(long long*)&t[i];

        if (x != y) return false;

        long long x1 = *(long long*)&s[i + 8];
        long long y1 = *(long long*)&t[i + 8];
    
        if (x1 != y1) return false;
    }

    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```

Получили 0.24 секунды.

Также хочется отметить, что ифы это долго. Поэтому от них лучше избавляться. Воспользуемся битовыми операциями


```
bool is_eq(char *s, char *t, int n) {
    int i = 0;

    for (; i + 16 <= n; i += 16) {
        long long x = *(long long*)&s[i];
        long long y = *(long long*)&t[i];
        
        long long x1 = *(long long*)&s[i + 8];
        long long y1 = *(long long*)&t[i + 8];
    
        if ((x ^ y) | (x1 ^ y1))
            return false;        
    }

    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```

> В целом вы не ограничены в том насколько надо разворачивать циклы.

Тут получим 0.23 секунды.

Можно заметить, что этот иф в среднем будет ускорять, но в худшем случае (2 равные строки) он будет ухудшать. Чтобы убрать иф, можно хранить отдельную переменную ans, и в цикле делать `ans |= (x ^ y) | (x1 ^ y1)`. Поэтому действуйте по ситуации.

> Комментарий: с этой штукой получил 0.26с -_-

### Так называемое заключение
Идея в том, что много маленьких штучек можно запихать в 1 большую и делать операции над ними за быстро.

### Ближе к делу

Есть sse он 128 битный, а есть avx он уже 256 битный, еще есть avx512 он 512 битный. Однако на большинстве тест систем avx512 увы нет.

Существуют так называемые регистры, в avx/avx2 их 16 по 256 бит, а в sse их 16 по 128 бит.

Чтобы работать с этими смешными штуками, надо подключить библиотеку: `#include <immintrin.h>`, она хранит в себе так называемые интринсики (вставьте определение). И еще прагму прописать: `#pragma GCC target("avx2")`.
> immintrin лучше подключать после прагм.

Я лично пишу так:
```
#include <bits/stdc++.h>
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#include <immintrin.h>
```

__mm256i - это тип данных чтобы хранить эти ваши регистры.

Давайте напишем сравнение двух строк:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 32 <= n; i += 32) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        
        if (!_mm256_testc_si256(ra, _mm256_xor_si256(rs, rt)))
            return false;
    }
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

это работает за 0.30s

в $256$ битный регистр помещается $32$ чара.

Что произошло:  
`_mm256_setzero_si256()` - возвращает регистр заполненный 0  
`_mm256_lddqu_si256` - загружает в регистр данные из памяти  
`_mm256_xor_si256` - побитовый xor  
`_mm256_testc_si256(a, b)` - возвращает (and(not(a), b) == 0)

Мы сначала создали $ra$ заполненный нулями, далее в цикле выгрузили данные из $s$ и $t$ в $rs$ и $rt$ соответственно. Далее проверили `(and(not(ra), xor(rs, rt)) == 0)` если $rs$ и $rt$ где-то будут не равны то там будет $1$ и тогда все значение не будет равно $0$, значит нам нужно чтобы $testc$ вернул $0$. 


> чтобы запихать что-то из памяти в функцию надо написать так: `(__m256i*)&x` 

также можно написать без ифа:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 32 <= n; i += 32) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        ra = _mm256_or_si256(ra, _mm256_xor_si256(rs, rt));
    }

    long long z[4];
    _mm256_storeu_si256((__m256i*)&z, ra);
    if (z[0] | z[1] | z[2] | z[3])
        return false;
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

Это за работает 0.32s

Што произошло:  
`_mm256_setzero_si256()` - возвращает регистр заполненный 0   
`_mm256_lddqu_si256` - загружает в регистр данные из памяти  
`_mm256_or_si256` - побитовый or  
`_mm256_xor_si256` - побитовый xor  
`_mm256_storeu_si256` - выгружает из регистра в память  

Мы сначала создали хранилище для ответов, потом внутри цикла выгрузили $32$ чара из $s$ и $t$. Далее проксорили их чтобы найти различия. И к ответу сделали |=. В конце выгрузили из регистра в массив из $4$ лонгов и проверили на наличие различий.

Мы все еще можем разворачивать циклы:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 64 <= n; i += 64) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rs1 = _mm256_lddqu_si256((__m256i*)&s[i + 32]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        __m256i rt1 = _mm256_lddqu_si256((__m256i*)&t[i + 32]);
        
        if (!_mm256_testc_si256(ra, _mm256_or_si256(_mm256_xor_si256(rs, rt), _mm256_xor_si256(rs1, rt1))))
            return false;
    }
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

Это работает за 0.22

Вариант без ифоф:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 64 <= n; i += 64) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rs1 = _mm256_lddqu_si256((__m256i*)&s[i + 32]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        __m256i rt1 = _mm256_lddqu_si256((__m256i*)&t[i + 32]);
        
        ra = _mm256_or_si256(ra, _mm256_or_si256(_mm256_xor_si256(rs, rt), 
                                                _mm256_xor_si256(rs1, rt1)));
    }

    long long z[4];
    _mm256_storeu_si256((__m256i*)&z, ra);
    if (z[0] | z[1] | z[2] | z[3])
        return false;
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

Это тоже работает за 0.22

### Так называемая идейность
Ну мы берем и кучу подряд идущих данных пихаем в регистр и с помощью интринсиков как-то манипулируем с ними. Иногда можем выгружать их обратно в память. В целом это все.

### Базовый минимум функций:

> Ну так к слову: в 256 бит помещается 4 лонга, 8 интов, 32 чара.  
> !!! если у вас древнейший комп, то надо юзать loadu вместо lddqu  

> !!! нельзя забывать что у вас всего 16 регистров, поэтому старайтесь не превышать это число, иначе вы потеряете в производительности. Будьте осторожны при unroll.

Работа с памятью:

`_mm256_lddqu_si256()` - принимает штуку вида (__m256i*)&x, возвращает регистр в которую скопировал данные из x;  
`_mm256_storeu_si256()` - принимает штуку вида (__m256i*)&x и регистр, записывает в x данные из регистра.  

Битовые штучки:

`_mm256_or_si256()` - принимает 2 регистра r1, r2 и возвращает or(r1, r2)  
`_mm256_xor_si256()` - принимает 2 регистра r1, r2 и возвращает xor(r1, r2)  
`_mm256_and_si256()` - принимает 2 регистра r1, r2 и возвращает and(r1, r2)  
`_mm256_andnot_si256()` - принимает 2 регистра r1, r2 и возвращает and(not(r1), r2)  
`_mm256_testz_si256()` - принимает 2 регистра r1, r2 и возвращает число равное (and(r1, r2) == 0)  
`_mm256_testc_si256()` - принимает 2 регистра r1, r2 и возвращает число равное (and(not(r1), r2) == 0)  

Наполнение регистров:

`_mm256_setzero_si256` - возвращает регистр заполненный нулями
`_mm256_set1_epi32(x)`- принимает инт и возвращает регистр с интами равными x.  

Арифметика:

`_mm256_add_epi32(a, b)` - принимает 2 регистра с интами и возвращает регистр с поэлементной суммой, т.е. a[i] + b[i].  
`_mm256_sub_epi32(a, b)` - возвращает регистр с разностью интов a[i] - b[i]  
`_mm256_abs_epi32(a)` - возвращает регистр интов равный abs(a[i])  

Мин/макс:

`_mm256_max_epi32(a, b)` - возвращает регистр интов равный max(a[i], b[i])  
`_mm256_min_epi32(a, b)` - возвращает регистр интов равный min(a[i], b[i])  

Сравнение:

`_mm256_cmpeq_epi32(a, b)` - возвращает регистр интов равный -1 если a[i] == b[i], и 0 иначе.  
`_mm256_cmpgt_epi32(a, b)` - возвращает регистр интов равный -1 если a[i] > b[i], и 0 иначе


> суффикc `epi32` означает что оно работает с интами, а `epi64` с лонгами, есть еще `epi16`, `epi8` по аналогии. Выше были представлены только для интов, для остального поищите в документации https://laruence.com/sse/#techs=AVX,AVX2,FMA.

> также есть суффик `si256` означает что ему без разницы что там инты лонги и тп. оно работает с битами.

Еще больше таких приколюх можете поискать здесь: https://laruence.com/sse/#techs=AVX,AVX2,FMA


### Оценка скорости
У интринсиков есть так называемое latency, это можно глянуть [здесь](https://laruence.com/sse/#techs=AVX,AVX2,FMA), если тыкнуть на что-нибудь, снизу можно увидеть абзац performance.

У какого-нибудь `_mm256_xor_si256` latency равен 1, а у `_mm256_lddqu_si256` он равен 7. И можно сказать что xor примерно в 7 раз быстрее lddqu. В общем важно понимать, что 3 load не будут также быстро работать как 3 xor.

### Ускорение lddqu/loadu и storeu
Можно заменить lddqu на load, а storeu на store. Возможно это ускорит вашу прогу примерно в 1.5-2 раза. Однако load и store требует выравнивания. Иначе может все сломаться.

Шо такое выравнивание: адрес с которого начинается считывание должен быть кратен 32 байтам.

как выровнять:
```
for (; i < n && (uintptr_t)&s[i]&31; i++)
```

А если старт начинается от начала массива то можно выровнять с помощью `alignas(32)` перед объявлением массива пишите и можно пользоваться.

и получим стартовый $i$ кратый 32 байтам, далее мы будем прибавлять по 256 бит, что равно 32 байтам поэтому остаток не будет меняться.

давайте попробуем ускорить наше сравнение строк:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();

    for (; i < n && (uintptr_t)&s[i]&31; i++)
        if (s[i] != t[i])
            return false;

    for (; i + 64 <= n; i += 64) {
        __m256i rs = _mm256_load_si256((__m256i*)&s[i]);
        __m256i rs1 = _mm256_load_si256((__m256i*)&s[i + 32]);
        
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        __m256i rt1 = _mm256_lddqu_si256((__m256i*)&t[i + 32]);
        
        ra = _mm256_or_si256(ra, _mm256_or_si256(_mm256_xor_si256(rs, rt), 
                                                _mm256_xor_si256(rs1, rt1)));
    }

    alignas(32) long long z[4];
    _mm256_store_si256((__m256i*)&z, ra);
    if (z[0] | z[1] | z[2] | z[3])
        return false;
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

так как мы выравнили только для s, поэтому load сможем применить только к s. Еще с помощью alignas я выровнял массив z.  
Я получил 0.15с. 

### лонги?

Допустим вы захотели интовый массив считать как лонг (Например сумма интов не помещается в инт). В этом вам поможет `_mm256_cvtepi32_epi64`
> там можно конвертить не только из интов в лонги, подробнее читайте в документации.

```
for (; i + 4 <= n; i += 4) {
    __m128i r1 = _mm_load_si128((__m128i*)&a[i]);
    __m256i r2 = _mm256_cvtepi32_epi64(r1);
    ...
}
```

Что произошло:
так называемый cvtepi принимает 128 битный регистр интов и превращает его в 256 битный регистр лонгов. Поэтому мы считали это в 128 битный регистр.

### Подпивасные советы
1. Первое не забывайте про количество регистров, чтобы сохранить хорошую производительность. И старайтесь не создавать больше чем 16 штук.

2. a | b | c | d это 3 операции, а (a | b) | (c | d) это 2 операции, ведь операции в скобках так сказать "распаралелились"

3. анролить можно не только в 2 раза, но и в 3 и в 4 и в 8. Однако вы ограничены количеством регистров.

4. Инструкции 1 рода лучше ставить подряд. Так будет немного быстрее. Например:
```
load
load

xor
and

store
store
```

### Пример с числовыми массивами

Итак, выше мы разобрали пример со строками. Давайте же попробуем решить простеньку задачу. Есть массив длинной $10^5$, каждый элемент до $10^5$, и $10^5$ запросов двух типов:

1. += на отрезке (гарантируется, что по-итогу каждый элемент не будет превышать память интов [гарантия для простоты разбора, иначе бы пришлось решать задачу в лонг лонг, а как решить задачу в лонг лонг - задача на подумать]). Его вид - 0 l r x

2. максимум на отрезке. Его вид - 1 l r

Каждый запрос мы будет выполнять векторизацией и сравним с тупой реализацией:=

```

#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 1;

int a[N];

int main() {
	int n, q; cin >> n >> q;
	for(int i = 0; i < n; i++) cin >> a[i];
	while(q--) {
		int tp; cin >> tp;
		if(tp == 0) {
			int l, r, x; cin >> l >> r >> x;
			l--; r--;
			for(int i = l; i < r; i++) a[i] += x;
		}
		else {
			int l, r; cin >> l >> r;
			l--; r--;
			int mx = -1e8;
			for(int i = l; i < r; i++) mx = max(mx, a[i]);
			cout << mx << '\n';
		}
	}
}

```

Выше представлена тупая реализация задачи, которая работает на макс тесте $10$ секунд. Долго, согласитесь? Вскрое вы увидите магию, из-за которой данная задача будет работать $< 2$ секунд. Давайте применим векторизацю для $1$ого запроса, тогда код станет выглядеть так:

```

#include <bits/stdc++.h>
#include <cstdio>
#include <immintrin.h>

#pragma GCC target("avx2")

using namespace std;

const int N = 1e5 + 1;

int a[N];

int main() {
	int n, q; cin >> n >> q;
	for(int i = 0; i < n; i++) cin >> a[i];
	while(q--) {
		int tp; cin >> tp;
		if(tp == 0) {
			int l, r, x; cin >> l >> r >> x;
			l--; r--;
			int i = l;
			__m256i buben = _mm256_set1_epi32(x);
			for (; i + 7 < r; i += 8) {
				__m256i bebra = _mm256_loadu_si256((__m256i*)&a[i]);
				__m256i pls = _mm256_add_epi32(bebra, buben);
		    	_mm256_storeu_si256((__m256i*)&a[i], pls);
			}
			for (; i < r; i++) a[i] += x;
		}
		else {
			int l, r; cin >> l >> r;
			l--; r--;
			int mx = -1e8;
			for(int i = l; i < r; i++) mx = max(mx, a[i]);
			cout << mx << '\n';
		}
	}
}

```

Данная реализация работает уже 2.5 секунды!!! 

>Велика вероятностсь, что += на отрезке сгенерировалось в макс тесте слишком мало :)

Давайте теперь оптимизируем вторую операцию векторизацией:

```
#include <bits/stdc++.h>
#include <immintrin.h>

#pragma GCC target("avx2")

using namespace std;

const int N = 1e5 + 1;

int a[N];

int main() {
	int n, q; cin >> n >> q;
	for(int i = 0; i < n; i++) cin >> a[i];
	while(q--) {
		int tp; cin >> tp;
		if(tp == 0) {
			int l, r, x; cin >> l >> r >> x;
			l--; r--;
			int i = l;
			__m256i buben = _mm256_set1_epi32(x);
			for (; i + 7 < r; i += 8) {
				__m256i bebra = _mm256_loadu_si256((__m256i*)&a[i]);
				__m256i pls = _mm256_add_epi32(bebra, buben);
		    	_mm256_storeu_si256((__m256i*)&a[i], pls);
			}
			for (; i < r; i++) a[i] += x;
		}
		else {
			int l, r; cin >> l >> r;
			l--; r--;
			int mx = 0, i = l;
			__m256i mx_avx = _mm256_set1_epi32(0);
			for (; i + 7 < n; i += 8) {
				__m256i bebra = _mm256_loadu_si256((__m256i*)&a[i]);
				mx_avx = _mm256_max_epi32(mx_avx, bebra);
			}
			int res[8];
			_mm256_storeu_si256((__m256i*)&res, mx_avx);
			mx = *max_element(res, res + 8);
			for (; i < r; i++) mx = max(mx, a[i]);
			cout << mx << '\n';
		}
	}
}

```

Предфинальная реализация работает за 1.8 секунды!!!!! Но это еще не все: добавим агрессии компилятору в виде `О3` и развертку циклов с помощью `unroll-loops` и получим работу кода в 0.534 секунды:)
Реализация:

```

#include <bits/stdc++.h>
#include <immintrin.h>

#pragma GCC target("avx2")
#pragma GCC optimize("unroll-loops")
#pragma GCC optimize("O3")

using namespace std;

const int N = 1e5 + 1;

int a[N];

int main() {
	auto start = clock();
	int n, q; cin >> n >> q;
	for(int i = 0; i < n; i++) cin >> a[i];
	while(q--) {
		int tp; cin >> tp;
		if(tp == 0) {
			int l, r, x; cin >> l >> r >> x;
			l--; r--;
			int i = l;
			__m256i buben = _mm256_set1_epi32(x * !tp);
			for (; i + 7 < r; i += 8) {
				__m256i bebra = _mm256_loadu_si256((__m256i*)&a[i]);
				__m256i pls = _mm256_add_epi32(bebra, buben);
		    	_mm256_storeu_si256((__m256i*)&a[i], pls);
			}
			for (; i < r; i++) a[i] += x;
		}
		else {
			int l, r; cin >> l >> r;
			l--; r--;
			int mx = 0, i = l;
			__m256i mx_avx = _mm256_set1_epi32(0);
			for (; i + 7 < n; i += 8) {
				__m256i bebra = _mm256_loadu_si256((__m256i*)&a[i]);
				mx_avx = _mm256_max_epi32(mx_avx, bebra);
			}
			int res[8];
			_mm256_storeu_si256((__m256i*)&res, mx_avx);
			mx = *max_element(res, res + 8);
			for (; i < r; i++) mx = (mx < a[i] ? a[i] : mx);
			cout << mx << '\n';
		}
	}
}

```

### Примеры на серьезной задаче 

Выше мы разобрали одни из способов применения векторизации. Теперь давайте выйдем на новый уровень и попробуем решить гроб с codeforces с рейтингом 2700. Задача: https://codeforces.com/problemset/problem/1511/G.

> тыкните на решение, чтобы развернуть

<details>
    <summary>Решение: </summary>
    Для начала давайте подумаем, к чему сводится данная задача, а свести ее можно к самой обычной теории нима (почему можно это: http://e-maxx.ru/algo/sprague_grundy). Прочитав данный конспект, станет очевидно, почему это ним), а именно нужно посчитать ксор по всем таким c[i] - L[i], что L[i] <= c[i] <= R[i]. Для нахождения таких элементов давайте отсортируем весь массив. Конкретно сама функция определения выигрыша проигрыша будет высчитываться так: F(l, r) = ((a[l] - x) ^ (a[l + 1] - x) ^ ... ^ (a[r] - x)), где l - это самое индекс c[i] в условии для нима, а r - индекс самого последнего c[i] в условии для нима, ну а х - это наше L[i] в запросе. Но как же нам найти этот ксор на отрезке??? Ведь отрезок может достигать длины 2 * 10^5... И тут на помощь приходит наша 
векторизация! Давайте напишем нашу функцию пошагово:  

1) Давайте поймем, что каждое значение на вводе не превышает лимит int'a, тогда наш 256ой регистр будет принимать по 8 интов.

2) Давайте подумаем, какие инструкции нам понадобятся

   2.1. `_mm256_loadu_si256((__m256i*) &a[i])` - для перегрузки массива в регистр, ведь без него, очевидно, мы не реализуем решение задачи
   
   2.2. `_mm256_storeu_si256((__m256i*) &a, b)` - для перегрузки регистра в массив, ведь без него мы не посчитаем ответ в нормальном виде
   
   2.3. `_mm256_set1_epi32(bebra)` - это что-то новенько! Данная инструкция позволяет заполнить весь 256ой регистр значением bebra. Количество "ячеек" в регистре зависит от типа данных bebra
   
   2.4. `_mm256_sub_epi32(x, y)` - это что-то новенькое! Данная инструкция позволяет выполнять операцию x[i] - y[i], где i - это индекс "ячейки" в нашем регистре. Подразумевается, что количество ячеек в регистрах х и у одинаковое

   2.5. `_mm256_xor_si256(x, y)` - ну с этим вы уже знакомы.
3) Хм, мы знаем какую функцию мы хотим векторизовать и знаем какие инструкции применять. Имея логику, можно решить эту задачу! Вот само решение:

```
int xor_on_segment(int l, int r, int lb) {
    // if (r - l + 1 >= 1) {
    //     int ans = 0;
    //     for (int i = l; i < r; i++) ans ^= (a[i] - lb);
    //     return ans;
    // }
    __m256i result =  _mm256_setzero_si256();
    __m256i lb_vec = _mm256_set1_epi32(lb);
    int i = l;
    for (i = l; i + 7 < r; i += 8) {
        __m256i avx_seg = _mm256_loadu_si256((__m256i*) &a[i]);
        __m256i sub_seg = _mm256_sub_epi32(avx_seg,lb_vec);
        result = _mm256_xor_si256(result, sub_seg);
    }
    alignas(16) int tmp[8];
    _mm256_storeu_si256((__m256i*) &tmp[0], result);
    int ans = 0;
    ans ^= tmp[0] ^ tmp[1] ^ tmp[2] ^ tmp[3] ^ tmp[4] ^ tmp[5] ^ tmp[6] ^ tmp[7];
    for (; i < r; i++) ans ^= (a[i] - lb);
    return ans;
}

```

Сама посылка решения: https://codeforces.com/contest/1511/submission/328505539. Можно убедиться, что наше решение вполне укладывается в time limit.

Так же стоит учитывать, что Егор Начкин имеет руки не из плеч, и в случае вашей реализации данное решение может иметь лучшее время работы.
</details>


### Подведем итоги:

Векторизация, или же AVX - это способ взять какую-то простетскую операцию и с помощью магии выполнять ее не на 1-ом элементе, а сразу на нескольких.

Надеемся, что вам понравился наш гайд, советуем вам для продвижение дальше в чудесном мире оптимизаций порешать контест великого Горнака: https://algocourses.ru/avx2024/

Прочитать мудрую теорию: https://algorithmica.org/ru/sse , https://habr.com/ru/articles/440566/ , https://habr.com/ru/articles/440632/.

А так же осталось некое множество задач, которое оставляем вам для закрепления и новых вами изученных позже инструкций:
https://codeforces.com/group/TGu8YtKKmk/contests
