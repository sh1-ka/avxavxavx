# Шедеврогайд по авх
> Если есть возражения или предложения по этому гайду, то мяукните мне в тг: o2kar1n.  

### Так называемое введение
Вы когда-нибудь мечтали стать лучшей версией себя? А огромные и стальные яйца? Или же запихать $10^{10}$ в секунду? Авх вам в этом поможет!!!

>Миниприкол: совсем простые вещи современный компиль может сам соптимайзить, поэтому моментами можно будет не писать все ручками.

### Сравнение 2 строк

> минигайд по указателям:  
> не чета не хочу пока

напишем функцию для сравнения 2 строк одиннаковой длины:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```

Тут видно, что он работает за n

попробуем это ускорить, а именно будем вместо чаров фигачить лонги, ведь как мы знаем в 1 лонг лонг можно запихать 8 чаров

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    for (; i + 8 <= n; i += 8) {
        long long x = *(long long*)&s[i];
        long long y = *(long long*)&t[i];
        if (x != y)
            return false;
    }

    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```
> Не стоит забывать что длина может не быть кратной 8, поэтому надо еще проверить остаток.

Что тут произошло:  
Мы взяли и перекастовали 8 чаров в 1 лонг лонг. И работали сразу с 8 элементами.

Вот щас вы подумаете, что это будет работать в 8 раз быстрее, но увы реальность полна разочарований. Давайте глянем на тесты:

> Время измерялось таким образом:
> ```
> auto start = clock();
> cout << is_eq(s, t, N) << '\n';
> auto end = clock();
> double time = (double)(end - start) / CLOCKS_PER_SEC;
> cout << time;
> ```

сравним 2 одиннаковые строки при $ N =  10 ^ 9 $:

| первый вариант | второй вариант |
|----------------|----------------|
|1.22s            |0.4s            |


Но буст всеравно хороший. Поэтому такие смешные штуки делать можно.

Еще из смешного можно разворачивать циклы.

> Если вы не знали, то существует прагма которая разворачивает циклы: `#pragma GCC optimize("unroll-loops")`, но ручками может быть быстрее

Давайте попробуем это сделать:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    for (; i + 16 <= n; i += 16) {
        long long x = *(long long*)&s[i];
        long long y = *(long long*)&t[i];

        if (x != y) return false;

        long long x1 = *(long long*)&s[i + 8];
        long long y1 = *(long long*)&t[i + 8];
    
        if (x1 != y1) return false;
    }

    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```

Получили 0.24 секунды.

Также хочется отметить, что ифы это долго. Поэтому от них лучше избавляться. Воспользуемся битовыми операциями


```
bool is_eq(char *s, char *t, int n) {
    int i = 0;

    for (; i + 16 <= n; i += 16) {
        long long x = *(long long*)&s[i];
        long long y = *(long long*)&t[i];
        
        long long x1 = *(long long*)&s[i + 8];
        long long y1 = *(long long*)&t[i + 8];
    
        if ((x ^ y) | (x1 ^ y1))
            return false;        
    }

    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    return true;
}
```

> В целом вы не ограничены в том насколько надо разворачивать циклы.

Тут получим 0.23 секунды.

Можно заметить, что этот иф в среднем будет ускорять, но в худшем случае (2 равные строки) он будет ухудшать. Чтобы убрать иф, можно хранить отдельную переменную ans, и в цикле делать `ans |= (x ^ y) | (x1 ^ y1)`. Поэтому действуйте по ситуации.

> Комментарий: с этой штукой получил 0.26с -_-

#### Так называемое заключение
Идея в том, что много маленьких штучек можно запихать в 1 большую и делать операции над ними за быстро.

### Ближе к делу

Есть sse он 128 битный, а есть avx он уже 256 битный, еще есть avx512 он 512 битный. Однако на большинстве тест систем avx512 увы нет.

Существуют так называемые регистры, в avx/avx2 их 16 по 256 бит, а в sse их 16 по 128 бит.

Чтобы работать с этими смешными штуками, надо подключить библиотеку: `#include <immintrin.h>`, она хранит в себе так называемые интринсики (вставьте определение). И еще прагму прописать: `#pragma GCC target("avx2")`.
> immintrin лучше подключать после прагм.

Я лично пишу так:
```
#include <bits/stdc++.h>
#pragma GCC optimize("O3,unroll-loops")
#pragma GCC target("avx2")
#include <immintrin.h>
```

__mm256i - это тип данных чтобы хранить эти ваши регистры.

Давайте напишем сравнение двух строк:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 32 <= n; i += 32) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        
        if (!_mm256_testc_si256(ra, _mm256_xor_si256(rs, rt)))
            return false;
    }
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

это работает за 0.30s

в $256$ битный регистр помещается $32$ чара.

Что произошло:  
`_mm256_setzero_si256()` - возвращает регистр заполненный 0  
`_mm256_lddqu_si256` - загружает в регистр данные из памяти  
`_mm256_xor_si256` - побитовый xor  
`_mm256_testc_si256(a, b)` - возвращает (and(not(a), b) == 0)

Мы сначала создали $ra$ заполненный нулями, далее в цикле выгрузили данные из $s$ и $t$ в $rs$ и $rt$ соответственно. Далее проверили `(and(not(ra), xor(rs, rt)) == 0)` если $rs$ и $rt$ где-то будут не равны то там будет $1$ и тогда все значение не будет равно $0$, значит нам нужно чтобы $testc$ вернул $0$. 


> чтобы запихать что-то из памяти в функцию надо написать так: `(__m256i*)&x` 

также можно написать без ифа:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 32 <= n; i += 32) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        ra = _mm256_or_si256(ra, _mm256_xor_si256(rs, rt));
    }

    long long z[4];
    _mm256_storeu_si256((__m256i*)&z, ra);
    if (z[0] | z[1] | z[2] | z[3])
        return false;
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

Это за работает 0.32s

Што произошло:  
`_mm256_setzero_si256()` - возвращает регистр заполненный 0   
`_mm256_lddqu_si256` - загружает в регистр данные из памяти  
`_mm256_or_si256` - побитовый or  
`_mm256_xor_si256` - побитовый xor  
`_mm256_storeu_si256` - выгружает из регистра в память  

Мы сначала создали хранилище для ответов, потом внутри цикла выгрузили $32$ чара из $s$ и $t$. Далее проксорили их чтобы найти различия. И к ответу сделали |=. В конце выгрузили из регистра в массив из $4$ лонгов и проверили на наличие различий.

---
Еще раз:


> !!! если у вас древнейший комп, то надо юзать loadu вместо lddqu

`_mm256_lddqu_si256()` - принимает штуку вида (__m256i*)&x, возвращает регистр в которую скопировал данные из x;  
`_mm256_storeu_si256()` - принимает штуку вида (__m256i*)&x и регистр, записывает в x данные из регистра.  
`_mm256_or_si256()` - принимает 2 регистра r1, r2 и возвращает or(r1, r2)  
`_mm256_xor_si256()` - принимает 2 регистра r1, r2 и возвращает xor(r1, r2)  
`_mm256_and_si256()` - принимает 2 регистра r1, r2 и возвращает and(r1, r2)  
`_mm256_andnot_si256()` - принимает 2 регистра r1, r2 и возвращает and(not(r1), r2)  
`_mm256_testz_si256()` - принимает 2 регистра r1, r2 и возвращает число равное (and(r1, r2) == 0)  
`_mm256_testc_si256()` - принимает 2 регистра r1, r2 и возвращает число равное (and(not(r1), r2) == 0)  
`_mm256_setzero_si256` - возвращает регистр заполненный нулями

Еще больше таких приколюх: https://laruence.com/sse/#techs=AVX,AVX2,FMA

Мы все еще можем разворачивать циклы:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 64 <= n; i += 64) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rs1 = _mm256_lddqu_si256((__m256i*)&s[i + 32]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        __m256i rt1 = _mm256_lddqu_si256((__m256i*)&t[i + 32]);
        
        if (!_mm256_testc_si256(ra, _mm256_or_si256(_mm256_xor_si256(rs, rt), _mm256_xor_si256(rs1, rt1))))
            return false;
    }
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

Это работает за 0.22

Вариант без ифоф:

```
bool is_eq(char *s, char *t, int n) {
    int i = 0;
    __m256i ra = _mm256_setzero_si256();
    for (; i + 64 <= n; i += 64) {
        __m256i rs = _mm256_lddqu_si256((__m256i*)&s[i]);
        __m256i rs1 = _mm256_lddqu_si256((__m256i*)&s[i + 32]);
        __m256i rt = _mm256_lddqu_si256((__m256i*)&t[i]);
        __m256i rt1 = _mm256_lddqu_si256((__m256i*)&t[i + 32]);
        
        ra = _mm256_or_si256(ra, _mm256_or_si256(_mm256_xor_si256(rs, rt), 
                                                _mm256_xor_si256(rs1, rt1)));
    }

    long long z[4];
    _mm256_storeu_si256((__m256i*)&z, ra);
    if (z[0] | z[1] | z[2] | z[3])
        return false;
    
    for (; i < n; i++)
        if (s[i] != t[i])
            return false;
    
    return true;
}
```

Это тоже работает за 0.22

### Так называемая идейность
Ну мы берем и кучу подряд идущих данных пихаем в регистр и с помощью интринсиков как-то манипулируем с ними. Иногда можем выгружать их обратно в память. В целом это все.

### Примеры на задачах

Выше мы разобрали один из способов применения векторизации. Теперь давайте выйдем на новый уровень и попробуем решить гроб с codeforces с рейтингом 2700. Задача: https://codeforces.com/problemset/problem/1511/G.

<details>
    <summary>Решение: </summary>
    Для начала давайте подумаем, к чему сводится данная задача, а свести ее можно к самой обычной теории нима (почему можно это: http://e-maxx.ru/algo/sprague_grundy). Прочитав данный конспект, станет очевидно, почему это ним), а именно нужно посчитать ксор по всем таким c[i] - L[i], что L[i] <= c[i] <= R[i]. Для нахождения таких элементов давайте отсортируем весь массив. Конкретно сама функция определения выигрыша проигрыша будет высчитываться так: F(l, r) = ((a[l] - x) ^ (a[l + 1] - x) ^ ... ^ (a[r] - x)), где l - это самое индекс c[i] в условии для нима, а r - индекс самого последнего c[i] в условии для нима, ну а х - это наше L[i] в запросе. Но как же нам найти этот ксор на отрезке??? Ведь отрезок может достигать длины 2 * 10^5... И тут на помощь приходит наша 
векторизация! Давайте напишем нашу функцию пошагово:  

1) Давайте поймем, что каждое значение на вводе не превышает лимит int'a, тогда наш 256ой регистр будет принимать по 8 интов.

2) Давайте подумаем, какие инструкции нам понадобятся

   2.1) _mm256_loadu_si256((__m256i*) &a[i]) - для перегрузки массива в регистр, ведь без него, очевидно, мы не реализуем решение задачи
   
   2.2) _mm256_storeu_si256((__m256i*) &a, b) - для перегрузки регистра в массив, ведь без него мы не посчитаем ответ в нормальном виде
   
   2.3) _mm256_set1_epi32(bebra) - это что-то новенько! Данная инструкция позволяет заполнить весь 256ой регистр значением bebra. Количество "ячеек" в регистре зависит от типа данных bebra
   
   2.4) _mm256_sub_epi64(x, y) - это что-то новенькое! Данная инструкция позволяет выполнять операцию x[i] - y[i], где i - это индекс "ячейки" в нашем регистре. Подразумевается, что количество ячеек в регистрах х и у одинаковое

   2.5) _mm256_xor_si256(x, y) - ну с этим вы уже знакомы.
3) Хм, мы знаем какую функцию мы хотим векторизовать и знаем какие инструкции применять. Имея логику, можно решить эту задачу! Вот само решение:

```
int xor_on_segment(int l, int r, int lb) {
    // if (r - l + 1 >= 1) {
    //     int ans = 0;
    //     for (int i = l; i < r; i++) ans ^= (a[i] - lb);
    //     return ans;
    // }
    __m256i result =  _mm256_setzero_si256();
    __m256i lb_vec = _mm256_set1_epi32(lb);
    int i = l;
    for (i = l; i + 7 < r; i += 8) {
        __m256i avx_seg = _mm256_loadu_si256((__m256i*) &a[i]);
        __m256i sub_seg = _mm256_sub_epi64(avx_seg,lb_vec);
        result = _mm256_xor_si256(result, sub_seg);
    }
    alignas(16) int tmp[8];
    _mm256_storeu_si256((__m256i*) &tmp[0], result);
    int ans = 0;
    ans ^= tmp[0] ^ tmp[1] ^ tmp[2] ^ tmp[3] ^ tmp[4] ^ tmp[5] ^ tmp[6] ^ tmp[7];
    for (; i < r; i++) ans ^= (a[i] - lb);
    return ans;
}

```

Сама посылка решения: https://codeforces.com/contest/1511/submission/328505539. Можно убедиться, что наше решение вполне укладывается в time limit.
</details>


